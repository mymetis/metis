[  ](id:top)

**Table of Contents**

- [Introduction](#Introduction)
- [Metis API](#Metis-API)
- [License](#License)
- [Packaging](#Packaging)
- [Configuration](#Configuration)
  - [Deployment Descriptor](#Deployment-Descriptor)
    - [\<servlet\> Tag](#servlet)
    - [\<servlet-mapping\> Tag](#servlet mapping)

<br>

<h2 id="Introduction">Introduction</h2>
[[back to top]](#top)

Representational State Transfer (REST) was originally conceived by Roy Fielding as an architecture style for distributed hypermedia. The World Wide Web (W<sup>3</sup>) is based on this style and it is the largest system that conforms to the REST principles. Roy Fielding is also one of the principal authors of  versions 1.0 and 1.1 of the HyperText Transfer Protocol (HTTP). REST was developed alongside these versions of HTTP, and version 1.1 was designed to conform to the REST style. This [Wikipedia page](http://en.wikipedia.org/wiki/Representational_state_transfer) provides a good synopsis on REST, as well as links to excellent reference material on the topic.

REST describes clients and servers, with clients initiating service requests to servers, and servers processing those requests and returning the appropriate service responses. Another way of viewing this is that servers publish services and clients consume those services. The requests and responses are centered on the manipulation of HTTP accessible resources through their representations. A resource is any logical and meaningful concept that may be addressed. On the W<sup>3</sup>, a representation of a resource is typically an HTML web page that captures the current state of that resource and is addressed by a Uniform Resource Identifier (URI) or  Uniform Resource Locator (URL). With respect to Metis, a resource is an entity (e.g., a student, a building, a classroom, etc.) object that is maintained in a data store or datasource (e.g., a database management system). For example, a student is an entity that is represented by a student database table and an instance of a student is maintained as a row in that table. Metis is a very lightweight, server-side framework that is used for quickly defining, implementing, and deploying Web application programming interfaces (APIs) that follow the REST architectural style. These Metis-based APIs are used by HTTP client applications to create, read, update, and delete entities (resources) that reside in their respective data store. Metis provides a very simple remote data access solution that allows a data store to quickly embrace the Web without the need to develop any server-side code.    Metis APIs provide remote data access to any number of different data stores. For example, an API can provide access to a database being hosted by the MySQL database management system (DBMS) and at the same time, also provide access to a database being hosted by the PostgreSQL DBMS. Metis provides access to any data store that has a Java Database Connectivity (JDBC) driver. There are many data stores, besides DBMSs, that have JDBC drivers; these are some examples: Google Spreadsheet, Microsoft Excel Spreadsheet, QuickBooks, Lightweight Directory Access Protocol (LDAP), Twitter, Intuit Data Services, Facebook, and Dynamics CRM. 
<h2 id="Metis-API">Metis API</h2>
[[back to top]](#top)

A Metis API comprises a set of HTTP request messages and their corresponding response messages. The signature of a particular request message, within an API, is represented by a base URL with optional parameters. For example, the following two URLs can represent API request messages that request information from a data store for a student whose student identification number is 123.*	www.gumpu.edu/admin/student/123*	www.gumpu.edu/admin/student?id=123A HTTP request message that is part of a Metis-based API is analogous to that of a function that is part of a procedural programming API or a method that is part of an object’s contract. Like a function or method, a request message is identified by its name and optional parameters (i.e., the function’s signature). A request message’s name is its base URL or URI and its optional parameters are passed in as either a URL-encoded string or one or more JavaScript Object Notation (JSON) objects. As in some object-oriented programming APIs, request messages that comprise a Metis-based API can be overloaded. For example, one particular URL can be assigned different sets of parameters, which results in overloading that URL. The information returned by the response message, to the client, is in the form of one or more [JSON](http://www.json.org) objects. Each JSON object is mapped from a row in a returned result set and comprises one or more key-value pairs; therefore, the returned JSON objects are considered flat and not hierarchical.  The key typically  identifies one of the entity’s attributes (table column) and the value represents the attribute’s current state.  Metis is not an Object-Relational Mapping (ORM) framework nor is it a HTTP-to-JDBC bridge that allows one to tunnel SQL via HTTP. With Metis, there is no SQL on the client side; just  URLs with their optional parameters. Although Metis is not an ORM framework, it is a frameowrk that allows HTTP clients to persist new resource representations to their respective data stores. These representations are specified via the JSON.   At its core, Metis comprises a JEE servlet that is configured through a combination of standard JEE deployment descriptor (i.e., web.xml) and Spring web application context (WAC) file. It is through these two configuration artifacts that one defines and implements Metis APIs. A single instance of a Metis servlet, which is defined in its corresponding web.xml file, implements a distinct API, and within a single web.xml file, one can define many Metis servlets. **One of the main advantages of using Metis is that it allows one to quickly define and implement RESTful remote data access APIs, and do so without having to develop any server-side code. Its as simple as configuring and deploying one or more Metis servlets.**   
<h2 id="License">License</h2>
[[back to top]](#top)

Metis is provided under the [Apache License v2.0](http://www.apache.org/licenses/LICENSE-2.0). 


<h2 id="Packaging">Packaging</h2>
[[back to top]](#top)

The Metis core product files (i.e., configuration and binary files) are packaged and deployed as a Web ARchive (WAR) file. The standard directory structure of a WAR is mainly comprised of the root directory (/) and its WEB-INF subdirectory. With the exception of the WEB-INF subdirectory, everything in the root directory is publicly accessible; it is a violation of the JEE specification to make the WEB-INF subdirectory and its contents publicly available. [This web page](http://docs.oracle.com/javaee/7/tutorial/doc/packaging003.htm) provides a good description of the Web ARchive and its directory structure:Because it is a JEE web application, Metis can be deployed onto any JEE servlet container (e.g., Apache Tomcat, Eclipse Jetty, JRun, Resin, etc.) and can, therefore, take advantage of all the services (e.g., security, fault-tolerance, load balancing) that are offered by the container. For example, you can use an application server's authentication and authorization services to control access to Metis APIs. Deploying a WAR file onto a servlet container is a procedure that differs from one container to the next; therefore, for details on how to deploy Metis, please consult the documentation for your corresponding servlet container. The Metis project provides a zip archive file (metis.zip) that includes a master Metis WAR file called, “metis.war”. Along with the necessary binary files (i.e., Java class and jar files), the master WAR file also includes a sample web.xml and WAC file. These two files, which also include lots of good documentation and examples, are template files that the end-user customizes for his or her particular environment. While reading through this guide, the reader is encouraged to also refer to these two template files. The following describes, in general, the process that one follows to create a customized Metis WAR file: 1.	Copy the metis.war file to a WAR file having the name of the application’s context or name space. For example, in keeping with the previous www.gumpu.edu/admin URL example, copy metis.war to admin.war. 2.	Using the jar command, extract the template web.xml and WAC file (sample-servlet.xml) from the metis.war file. For example:jar -xf metis.war WEB-INF/web.xml WEB-INF/sample-servlet.xml3.	Customize the web.xml file and rename and customize the sample-servlet.xml file. The sample-servlet.xml file will have to be re-named to match the servlet name that is chosen/defined in the web.xml file. If you define more than one servlet, you will have more than one WAC file. The customization of the web.xml and WAC files is the process through which one defines the APIs that the Metis servlet implements and services. Subsequent sections of this guide provide detailed information for this process.  4.	Using the ‘jar –u’ command, archive the modified files into the admin.war file.  For example, if you defined a servlet called “student”, use the following jar command: jar –uf admin.war WEB-INF/web.xml WEB-INF/student-servlet.xml5.	Deploy the WAR file onto the target servlet container. Here’s an alternative approach.1.	Extract or unjar the entire master metis.war file onto a target or build directory. For example, ‘jar -xf metis.war’. Make sure the metis.war file is not located in the resulting target directory. 2.	Within the target directory, customize the sample web.xml and clone and customize the WAC file. Again, the sample-servlet.xml will have to be re-named to match the servlet name that is defined in the web.xml file and if you define more than one servlet in the web.xml, you will have to create a corresponding number of WAC files.  3.	From the top level target directory archive the entire directory structure into a WAR file having the appropriate web application name. For example: jar  cf admin.war *4.	Deploy the WAR file onto the target servlet container. You may want to use the alternative approach if, for example, you are defining many servlets in your web.xml and thus have many corresponding WAC files.  Either approach may be repeated any number of times to produce distinct versions of the Metis WAR file. Each version, with its own unique name, represents a distinct JEE web application. For example, the organization that created the “admin.war” file decides they need a new Metis web application called “finance”, in which case they create a “finance.war” file. As previously mentioned, you can define any number of distinct versions of the Metis servlet within a single web.xml file, with each instance being assigned a different servlet path and WAC file.  For example, www.gumpu.edu/admin/student and www.gumpu.edu/admin/faculty are serviced by two distinct Metis servlets defined in a web.xml file that resides in the admin.war file. The **www.gumpu.edu** portion of the URL is called the *host name*, while the remaining portion is called the *path*. For a JEE web application, the path is further broken down into a *context* and *servlet* path. In the two given examples, the “admin” portion of the URL is the web application’s context (a.k.a., name space or web application name) , while the “faculty” and “student” portions are servlet paths.  The name assigned to a WAR file must match the application’s context, which in this example is “admin”.  In some cases, there may not be a servlet path associated with the URL. If this is the case, there is one servlet that services the URL that is comprised of only the host name and application context path.  For example, you can have a single servlet that services the www.gumpu.edu/admin URL, whose servlet path can be considered to be empty or simply “/”. 
 
<h2 id="Configuration">Configuration</h2>[[back to top]](#top)
As mentioned in the previous section, the core Metis product is packaged as a master WAR file called, “metis.war”. The metis.war file serves as a template, from which one creates one or more distinct production or runtime WAR files.  For example, from the metis.war file one can create the admin.war and finance.war files for the admin and finance application context paths, respectively. This section of the guide provides detailed information on how the template configuration files, which are found in the metis.war file, are customized to define one or more instances of a Metis servlet and the data access APIs that they implement and service. 
<h3 id="Deployment-Descriptor">Deployment Descriptor</h3>[[back to top]](#top)The deployment descriptor file is a required and standard JEE file having the fixed name of “web.xml”.  A WAR file contains only one web.xml file. The file’s main purpose is to define and configure one or more [Metis] servlets. It is also used to define the servlets’ URL [mapping rules](see http://javapapers.com/servlet/what-is-servlet-mapping). The mapping rules are used by the servlet container to route HTTP request messages to the servlets defined in the web.xml. For example, suppose you’ve defined a web application with a name space of, “admin” for the www.gumpu.com host name, and this application’s web.xml file defines two servlets called, “student” and “faculty”. The mapping rules in the web.xml are set up such that all requests made to www.gumpu.edu/admin/student and www.gumpu.edu/admin/faculty are sent to the “student” and “faculty” servlets, respectively. The following subsections of the guide describe the web.xml file’s XML elements and properties that apply to the Metis servlet. You are also encouraged to refer to the well-documented sample or template web.xml that is included in the master  metis.war file. There are some web.xml elements that do not apply or may indirectly apply to Metis. One example of the latter is the set of elements that are used to control access to servlets. Please refer to the following web sites for detailed descriptions of the web.xml file and all its elements:
*	http://docs.oracle.com/cd/E13222_01/wls/docs81/webapp/web_xml.html*	https://developers.google.com/appengine/docs/java/config/webxmlYou are also not precluded from introducing servlets, other than Metis servlets, to the web.xml. For example, you may introduce a servlet filter that transforms the Metis servlet’s response. See http://www.oracle.com/technetwork/java/filters-137243.html for more information on servlet filters.  
###	[\<servlet\> Tag](id:servlet)
[[back to top]](#top)The `<servlet>`  tag or element declares an instance of a servlet and its properties; you can declare many servlets in one web.xml. These are the more important Metis-relevant properties of the servlet element.1.	The name used to uniquely identify an instance of a Metis servlet within the context of the web.xml file. This name is also used by other elements (e.g., servlet-mapping), within the web.xml, to refer to the servlet.2.	The fully qualified servlet’s class name, which for the Metis servlet is, “org.metis.MetisServlet”3.	The Metis servlet’s initialization parameters.  Each instance of a Metis servlet that is declared in the web.xml must have a corresponding WAC file in the web application's WEB-INF subdirectory. By default, the WAC file name is constructed as follows: `<servlet name>`-servlet.xml. For example, the “student” Metis servlet must, by default, have a file in the WEB-INF subdirectory called, “student-servlet.xml”. The `<servlet name>` portion of the file name is referred to as the servlet’s name space. You can override this default name space by providing a “namespace” servlet initialization parameter (see the example “student” servlet declaration below); however, this is not recommended.  The WAC file, along with its elements and properties, is covered in a subsequent section. What follows is a sample Metis `<servlet>` XML element. 
``` XML
<servlet>     <!-- This is the servlet’s name, which is referenced by other elements in this deployment           descriptor file. All servlets defined in the deployment descriptor must be assigned          unique names. -->    <servlet-name>student</servlet-name>    <description>        This is the main dispatcher servlet for the Metis web application.      </description>    <!-- All Metis servlets defined in the deployment descriptor must be assigned this            servlet-class name. -->    <servlet-class>  org.metis.MetisServlet  </servlet-class>           <!--     Use the namespace init-param to override the default namespace for this servlet. Note that    by doing so, you will alter the name used to locate the target WAC file. So for example, if     the param below is enabled, the servlet will look for a WAC file by the name of     foo-servlet.xml, instead of student-servlet.xml.          <init-param>        <param-name>namespace</param-name>        <param-value>foo</param-value>    </init-param>    -->      <!--      Use the contextConfigLocation init-param to explicitly specify the  location of the WAC     file. The 'classpath:' prefix is used to specify that the file is located in the web application’s    classpath. You can also use the 'file:' prefix. If you do not use a prefix, the file should be    located in the WEB-INF subdirectory, which is the recommended and default directory.     <init-param>     <param-name>contextConfigLocation</param-name>     <param-value>classpath:WebServicesContext.xml</param-value>   </init-param>   --> <!--      Set this Boolean to true if all requests made to this servlet must be made by an    authenticated end-user. The default is false.     <init-param>        <param-name>authenticated</param-name>        <param-value>false</param-value>     </init-param>  -->		 <!--      Use the agentNames init-param to list those agent names that are and are not allowed 
    to make requests to this servlet. All names preceded with a ‘!’ will be disallowed.  
    The elements of this list are compared to the value of the User-Agent HTTP request 
    header. Please see the examples described immediately following this sample    web.xml.       <init-param>         <param-name>agentNames</param-name>         <param-value>agent1, agent2</param-value>     </init-param> -->		 <!--    Use the cacheControl init-param to specify the value assigned to the HTTP Cache-control
    response header. The default setting is “no-store, no-transform”.     <init-param>        <param-name>cacheControl</param-name>        <param-value>private, no-store, max-age=300</param-value>     </init-param>  -->    <!--        The <load-on-startup> element indicates that this servlet should be loaded     (i.e., instantiated and have its init() called) during the web application’s startup phase. The     optional contents of this element must be an integer  indicating the order in which the servlet    should be loaded. If the value is a negative integer, or the element is not present, the servlet     container is free to load the servlet whenever it chooses. If the value is >= 0, the container    must load and initialize the servlet as the application is  deployed. The container must     guarantee that servlets marked with lower  integers are loaded before servlets marked with    higher integers. The Metis should be loaded at server startup time.        -->    <load-on-startup>1</load-on-startup> </servlet>     ```
 The *agentNames* init-param is used as a control access mechanism. Here are some examples:•	Suppose agentNames is set to “!windows”. With this setting, all HTTP requests having an Agent-Name request header, whose value has the “windows” string present, will be disallowed; all others will be allowed. •	Suppose agentNames is set to “linux, osx”. With this setting, only those HTTP requests having an Agent-Name request header, whose value has the “linux” or “osx” string, will be allowed; all others will be disallowed. 

###	[\<servlet-mapping\> Tag](id:servlet mapping)

[[back to top]](#top)
The <servlet-mapping> XML element specifies a URL pattern that is assigned to a servlet. The URL pattern can use an asterisk (*) at the beginning or end of the pattern to indicate zero or more of any character. The standard does not support wildcards in the middle of a string, and does not allow multiple wildcards in one pattern. The pattern matches the path of the URL, starting with and including the forward slash (/) following the application’s context path. For example, if the full URL for the application is www.gumpu.com/admin, the mapping rule below will forward all URLs with the pattern www.gumpu.com/admin/student to the “student” servlet.<servlet-mapping>    <servlet-name>student</servlet-name>    <url-pattern>/student/*</url-pattern></servlet-mapping>Please note that the url-pattern value does not have to reflect the servlet-name value. In the above example, you could have assigned the url-pattern a value of  “/foo/*”, in which case the URL of  www.gumpu.com/admin/foo would be mapped to the student servlet. The following is taken from the JEE servlet specification:

```The path used for mapping to a servlet is the request URL from the request object minus the context path and the path parameters. The URL path mapping rules below are used in order. The first successful match is used with no further matches attempted:
1. The container will try to find an exact match of the path of the request to the path of the servlet. A successful match    
   selects the servlet.2. The container will recursively try to match the longest path-prefix. This is done by stepping down the path tree a 
   directory at a time, using the ’/’ character as a path separator. The longest match determines the servlet selected.3. If the last segment in the URL path contains an extension (e.g. .jsp), the servlet container will try to match a
   servlet that handles requests for the extension. An extension is defined as the part of the last segment after 
   the last ’.’ character.4. If neither of the previous three rules result in a servlet match, the container will attempt to serve content
   appropriate for the resource requested. If a "default" servlet is defined for the application, it will be used. 
   Many containers provide an implicit default servlet for serving content.The servlet container must use case-sensitive string comparisons for matching.```
This is the general syntax for the servlet mapping per the servlet specification:1.	A string beginning with a '/' character and ending with a '/*' suffix is used for path mapping.2.	A string beginning with a '*.' prefix is used as an extension mapping.3.	A string containing only the '/' character indicates the "default" servlet of the application. In this case the servlet path is the request URI minus the context path and the path info is null.4.	All other strings are used for exact matches only. The following two tables, which are also taken from the Servlet specification, provide mapping examples:**Example Set of Maps**Path Pattern | Servlet:-----------: |:--------:/foo/bar/*	 | servlet1
/baz/*	     | servlet2/catalog	 | servlet3*.bop	     | servlet4**Incoming Paths Applied to Above Maps**Incoming Pattern | Servlet Handling Request:----------------:|:------------------------:/foo/bar/index.html	|servlet1/foo/bar/index.bop	|servlet1/baz | servlet2/baz/index.html	| servelt2/catalog | servlet3/catalog/index.html|	“default” servlet/catalog/racecar.bop|servlet4index.bop|servlet4Note that in the case of /catalog/index.html and /catalog/racecar.bop, the servlet mapped to “/catalog” is not used because the match is not exact. You may define any number of servlet mappings, including zero; however, for this particular web application, you must assign a Metis servlet one or more mappings. If you wish to do so, it is perfectly legal to define more than one mapping for a particular servlet.
###	[\<distributable\> Tag](id:distributable)
[[back to top]](#top)
The JEE platform provides optional support for distributed web applications. A distributed web application runs simultaneously in multiple servlet containers. When a web application is marked distributable in its deployment descriptor, the container may (but is not required to) create multiple instances of the application’s servlets, in multiple JVM instances and potentially on multiple machines. Distributing a web application improves scalability, because it allows web request load to be spread across multiple servers. It can also improve availability by providing transparent failover between application instances. The Metis servlet is stateless; therefore, it can be marked distributable.  ###	security-constraintMetis relies on the hosting JEE application server or container for user authentication and authorization (a.k.a., container-managed or declarative security). In other words, it relies on the application server to control access to the Metis servlets that are defined in the deployment descriptor and their corresponding APIs. The <security-constraint> element defines a security constraint for URLs that match a pattern. If a user accesses a URL whose path has a security constraint and the user is not signed in, the application server redirects the user to the corresponding sign-in page. The application server redirects the user back to the application URL after successfully signing in. The JEE web application does not need to do anything else to ensure that only authenticated users can access the URL. A security constraint includes an authorization constraint that specifies which users can access the path. If the authorization constraint specifies a user role of *, then any authenticated user can access the URL. If the constraint specifies a user role of admin, then only registered developers (administrators) of the application can access the URL. The admin role makes it easy to build administrator-only sections of the site.  Please consult your JEE platform’s (servlet container or WAS) documentation to learn how to set up authentication and authorization. These are the links to a couple of the more popular servlet containers.    * Tomcat - http://tomcat.apache.org/tomcat-7.0-doc/realm-howto.html * Jetty - http://www.eclipse.org/jetty/documentation##	Web Application ContextExcept for the Metis servlet’s initialization parameters, which are unique to Metis, the previous section primarily dealt with those aspects of the product’s configuration that conform to the JEE web application standard. This section of the guide focuses entirely on those configuration aspects that are unique or proprietary to Metis.  The previous sections have also described how to begin to define a Metis-based API. It began by assigning a name to a WAR file, which equates to defining the web application’s name space  or context path. In the previous example, the “admin” name space was used in combination with a fictitious host name of “www.gumpu.edu”; therefore, the API’s request messages are represented, in part, by this combination of host name and name space: “www.gumpu.edu/admin”.  Within the corresponding admin.war file is the deployment descriptor file (web.xml), which is used to define servlets and their mappings. This continues the process of defining the APIs by specifying the “servlet paths”.  For example, “faculty” and “student” were chosen as two examples of a servlet path, which result in the following URLs:*	www.gumpu.edu/admin/student*	www.gumpu.edu/admin/facultySo with the above, one has defined the base URLs for two APIs and the servlets that will service/implement those APIs. All request messages that comprise each of the two APIs will be anchored by one of the above base URLs. In some cases, there may be only one servlet that services all HTTP request messages for a web application. In such a case, the base URL for the one API comprises only the host name and application name. For example, if the previously mentioned “admin” web application has only one API that is hosted and implemented by one servlet, then that one API would have a base URL of   www.gumpu.edu/admin Thus far, the guide has described the first phase of the API definition process. This section of the guide describes the next phase of that process and also describes how the API is implemented. ###	Resource Driven Bean As mentioned in a previous section of the guide, the name assigned to a WAC file must be constructed as follows:  <servlet name>-servlet.xml. For example, a Metis servlet with an assigned name of “faculty” must have a WAC file in the WEB-INF subdirectory called, “faculty-servlet.xml”. Please refer to the previous section to learn how to override this default behavior.  A servlet’s WAC file is used primarily for defining one or more resource driven beans (RDBs) that are assigned to the servlet.  A RDB is the Metis object that is responsible for servicing  all or a subset of the HTTP request messages that comprise an API. When a request message arrives at the servlet container, the container dispatches the request message to a servlet thread instance. Recall that the servlet mapping rules in the web.xml file inform the container on how to route request messages to servlets. The thread instance then dispatches the request message to one of its assigned RDBs.  The RDBs are thread-safe static objects; therefore, there is only one instance of a particular RDB and that one instance can be simultaneously accessed by many of the owning servlet’s threads of execution .  The following subsections describe the WAC file’s XML elements and properties. ###	RdbMapperA previous section of the guide described the base URL for a particular Metis-based API.  The following is an example of a previously given base URL: www.gumpu.edu/admin/student. Recall that www.gumpu.org, admin, and student are the host name, application name space, and servlet name space, respectively. The application and servlet name spaces are also referred to as the context and servlet paths, respectively. And also recall that servlet paths are defined in the web.xml to route HTTP request messages to the servlets defined in the web.xml. The WAC file uses a similar mapping rule that is used by the servlet to dispatch its incoming HTTP request messages to its RDBs.  This RDB mapping rule utilizes the part of the URL that follows the servlet path, which we’ll refer to as the “RDB path”.  For example, suppose the servlet container dispatches a request message, with the following URL, to the student servlet:  www.gumpu.edu/admin/student/parking. The “parking” string, which follows the “student” servlet path, is the RDB path that is used for dispatching the request from the servlet to one of its assigned RDBs.The RDB mapping logic resides in a Metis object called the “controller mapper”; its Java class name is “RdbMapper”.  It is this object that is assigned the above-mentioned RDB mapping rules.  To map RDB paths to RDBs, the RDB mapper uses an implementation of the Ant-style path patterns (see http://ant.apache.org/manual/dirtasks.html), which are very similar to the file inclusion patterns found in DOS and UNIX.  A WAC file must define one and only one  RDB mapper. The example RDB mapper bean definition below illustrates the use of the  RDB mapping rules.
```<bean id= “handlerMapping” class= “org.metis.pull.RdbMapper”>   <property name=  “mappings”>	<value>	     <!-- URLs ending with '/parking' will be mapped to the RDB  with a bean id of               'parkingrdb' -->		/parking=parkingrdb        <!-- URLs ending with '/profile' will be mapped to the RDB  with a bean id of             'profilerdb' -->		/profile=profilerdb	</value>   </property></bean>     ```Please note that **you must specify one and only one mapping rule per line**.   Also, refer to the sample-servlet.xml template file for more examples of RDB mapping rules and patterns. As previously mentioned, these Ant-style patterns look very much like the patterns used in DOS and UNIX. For example, '*' matches zero or more characters and '?' matches one character. Here are a few examples:*	*.java  matches  .java, x.java and FooBar.java, but not FooBar.xml (does not end with .java).*	?.java  matches  x.java, A.java, but not .java or xyz.java (both don't have one character before .java).*	/java/** matches any string that is prefixed with /java/. For example: /java/,  /java/bean, java/bean/1Combinations of *'s and ?'s are allowed.  You may also have a situation in which a servlet is assigned only one RDB. In this case, that one RDB services all of the API’s HTTP request messages. For example, if the previously mentioned “student” servlet is assigned only one RDB, the RDB mapper would be configured as follows:
```<bean id= “handlerMapping” class= “org.metis.pull.RdbMapper”>   <property name="mappings">	<value>		/**=studentrdb	</value>   </property></bean>     ```So with the above configured RDB mapper, all request messages having the following URL prefix will be serviced by the RDB having the name of  “studentrdb”:												www.gumpu.edu/admin/student To quickly recap the mapping: 1.	The servlet container uses the web.xml to route incoming HTTP service requests to those servlets defined for the corresponding application context (e.g., admin) 2.	The servlet uses its assigned RDB mapper bean, which is defined in the servlet’s WAC file, to route its service requests to one of the RDBs defined in the WAC file.  Now that we’ve described the RDB and the RDB mapper’s XML element, lets move on to the element that is used to define and configure a RDB. 
###	WdsResourceBeanThis element defines and configures a RDB that is referenced by the RDB mapper. If the RDB mapper makes reference to a RDB that is not defined in the WAC file, a fatal exception will occur and the corresponding Metis servlet will terminate immediately after starting.  A RDB is a statically configured, thread-safe JDBC client that runs within the context of a Metis web application. You can define any number of RDBs in the WAC file, with each being wired to a DataSource object. All RDBs must be wired to a DataSource object. The DataSource object is an implementation of a JDBC connection pool manager, which by default, is provided by the [Apache Tomcat JDBC Connection Pool](http://tomcat.apache.org/tomcat-7.0-doc/jdbc-pool.html) package. A JDBC connection pool is used to make very efficient use of connections to the target data store.  Also, please refer to the sample-servlet.xml template WAC file for more information on how to define and configure a DataSource bean or object. Here’s a snippet of a DataSource bean definition, as taken from the template file. 

```<bean id="dataSource" class="org.apache.tomcat.jdbc.pool.DataSource" destroy-method="close">   <property name="driverClassName" value="com.mysql.jdbc.Driver" />   <property name="url" value="jdbc:mysql://127.0.0.1:3306/myDatabase" />   <property name="username" value="admin" />   <property name="password" value="admin" />   <property name="initialSize" value="10" />   <property name="maxActive" value="10" />   <property name="maxIdle" value="5" />   <property name="minIdle" value="2" />   <property name="maxWait" value="2000" /></bean>	```
  Note in particular the “driverClassName” property.  This property is used to specify the JDBC driver class that the pool manager is supposed to use or load. In the above case, it is loading the MySQL JDBC driver. In order for the pool manager to load the class, the  JDBC driver’s Java ARchive (JAR) file must be located somewhere in the Metis web application’s classpath.  To ensure that the JDBC driver’s JAR file is in the Metis classpath, you can do one of the following:1.	When creating your custom Metis runtime WAR file, as described in the “Packaging” section, include the JDBC driver’s JAR file in the runtime WAR file. To do this, just copy it into the WEB-INF/lib directory prior to using the ‘jar’ command to create the runtime WAR file. You’ll notice a number of other JAR files in Metis’s WEB-INF/lib directory; these are Metis’s standard JAR files. In some cases, you may be defining APIs that provide access to different backend data stores; in which case, you will need to include a JDBC JAR file for each of the data stores. 2.	Option #1 makes the JDBC driver’s JAR file available only for a particular Metis web application. If you’d like to make the JAR file available globally for all web applications, then place the file in the servlet container’s global “lib” directory. For example, if you’re using Tomcat, place the JAR file in the $CATALINA_HOME/lib directory, and if you’re using Jetty, place it in the $JETTY_HOME/lib directory.    You can define more than one DataSource object in a WAC file; however, each object must have a distinct “bean id”, which applies to all the objects or beans that you define in the WAC file.  Each RDB must be wired to a DataSource, and each DataSource that you define uses a different JDBC driver. This would be the case if, for example, your environment is using different DBMSs.  JDBC drivers have their own unique properties that are passed to the driver as query parameters. For example, the following URL string value is used for assigning the 'noAccessToProcedureBodies' boolean property to the MySQL JDBC driver. 							"jdbc:mysql://127.0.0.1:3306/gumpu?noAccessToProcedureBodies=true"	Please refer to your JDBC driver for more information on its configuration properties. Here are example configurations for other DBMSs. Note the URLs being used are pointing to fictitious instances running on Amazon’s Remote Data Service (RDS). Oracle
```<bean id="dataSource" class="org.apache.tomcat.jdbc.pool.DataSource"	destroy-method="close">  <property name="driverClassName" value="oracle.jdbc.driver.OracleDriver" />  <property name="url" value="jdbc:oracle:thin:@abc-oracle.d7ywmbp22ofk.us-west-2.rds.amazonaws.com:1521/gumpu" />  <property name="username" value="admin" />  <property name="password" value="admin" />   <property name="initialSize" value="5" />  <property name="maxActive" value="10" />  <property name="maxIdle" value="5" />  <property name="minIdle" value="2" /></bean>```
 PostgreSQL```<bean id="dataSource" class="org.apache.tomcat.jdbc.pool.DataSource" destroy-method="close">  <property name="driverClassName" value="org.postgresql.Driver" />  <property name="url" value="jdbc:postgresql://abc-postgresql.c9ywmbp33ofk.us-west-6.rds.amazonaws.com:5432/gumpu" />  <property name="username" value="admin" />  <property name="password" value="admin" />   <property name="initialSize" value="5" />  <property name="maxActive" value="10" />  <property name="maxIdle" value="5" />  <property name="minIdle" value="2" /></bean>```SQL Server```<bean id="dataSource" class="org.apache.tomcat.jdbc.pool.DataSource"   destroy-method="close">  <property name="driverClassName" value="com.microsoft.sqlserver.jdbc.SQLServerDriver" />  <property name="url" value="jdbc:sqlserver://abc-sqlserver.d7ywmbp22ofk.us-west-2.rds.amazonaws.com:1433;databaseName=gumpu" />  <property name="username" value="admin" />  <property name="password" value="admin" />   <property name="initialSize" value="5" />  <property name="maxActive" value="10" />  <property name="maxIdle" value="5" />  <property name="minIdle" value="2" /></bean>```
	Note how the database name of “gumpu” is specified a little differently for SQL Server. That is, there is a ‘;’ instead of ‘/’, separating the port number of database name.  To quickly summarize: 
* Every RDB that is referenced by the RDB mapper, must be defined in the WAC file.* Every RDB must be wired to a DataSource.* Every DataSource must find its target JDBC driver class in the Metis web application’s class path.Now that the RDB and its DataSource have been introduced, lets focus on the RDB’s configuration element and properties. Every RDB must have a bean definition XML element with the following basic format:```<bean id="parkingrdb" class="org.metis.pull.WdsResourceBean">          body</bean>     ```
The RDB in the WAC file must have a “bean id” property value that is distinct from all other RDBs in the WAC file. In the sample snippet above, we’ve given the bean id property a value of “parkingrdb”. The value for the “class” property is the same for all RDBs. The body of the RDB XML element is where the majority of the RDB’s properties are specified. The following subsections describe the RDB’s properties. 
####	sqls4GetThe guide has, thus far, described how a RDB is wired to its JDBC DataSource object (i.e., JDBC connection pool), as well as  JDBC driver. This subsection, as well as the subsequent 3, describe how you assign SQL statements to the RDBs, and how these SQL statements are mapped to incoming HTTP request messages. In essence, this section and the next three describe how you implement the API that you have defined.  The “sqls4Get” RDB property is used for assigning the RDB a set of SQL statements that are bound to the HTTP GET method.  The RDB has three additional and similar properties called “sqls4Put”, “sqls4Post”, and “sqls4Delete” that are used for assigning SQL statements to the PUT, POST, and DELETE  HTTP methods, respectively. These three properties are covered in subsequent sections of the guide. Metis does not support any other HTTP method. Here’s an example of how you assign SQL statements to the “sqls4Get” property. 
```<bean id="parkingrdb" class="org.metis.pull.WdsResourceBean">   <property name="sqls4Get">       <list>	<value>select lotNumber from space where id = `integer:id`</value>	<value>select lotNumber from space where lastName like 			concat(`char:nameprefix`,'%') </value>     </list>   </property>   <!-- All RDBs must be assigned a DataSource! -->   <property name="dataSource" ref="dataSource" /> </bean> ```
 In the example above, two SQL statements have been assigned to the GET method, which also  illustrates how you can overload the GET method by assigning it more than one SQL statement.  Note how the two SQL statements have fields that are delimited by the backtick or grave accent ASCII character (i.e., ' \` '). These fields are called, “parameterized fields” and they are mapped or bound to a JDBC prepared statement as a ‘?’ character.  For example, this SQL statement, “select lotNumber from space where id =  \`integer:id\`  ”, will get transformed or mapped to the following JDBC prepared statement, “select lotNumber from space where id = ?”.A parameterized field is defined by these three sections: type, key, and mode.  The sections are delimited by the ‘:’ character.  The type is used to identify the field’s JDBC type (e.g., char, varchar, numeric, real, double, etc.) and the key serves as the field’s unique identifier. Please refer to the “JDBC Data Types” section of the guide for a complete list of the supported JDBC types. The mode, which is used only when the SQL statement is for a stored procedure, identifies the field as being of type IN, OUT, or INOUT. When the Metis servlet dispatches a HTTP request message to the RDB, the RDB uses the message’s parameters, which are key-value pairs, to match or map the request message to its  corresponding SQL statement. Suppose that a HTTP GET request message, with the following URL, is being processed by the RDB:											www.gumpu.edu/admin/student/parking?id=36The RDB with a bean id of parkingrdb is chosen because the RDB mapper was given a mapping rule that maps the RDB path of “/parking” to that RDB. When the RDB receives the GET request message, it checks to see if it (the RDB) has SQL statements bound to the GET method. If so, the RDB attempts to match the keys of the incoming message’s parameters to those of the SQL statements that have been bound to the GET method. In this particular example, it chooses the SQL statement that has the single parameterized field having a key of  “id”. If the parameter for the request message had a key of  “nameprefix”, instead of “id”, the other SQL statement would have been chosen. The set of SQL statements that is bound to the HTTP GET method must have elements that are  all distinct from one another. The distinction is made by the statement’s number of parameters and their key names. Suppose that an RDB has four SQL statements assigned to the GET method and the statements have parameterized fields as shown in the following table:
Statement Number |	Parameterized Fields:----------------:|:------------------------1	|\`integer:id\`2	|\`integer:id\`   \`char:first\`3	|\`integer:id\`   \`char:first\`   \`char:last\`4	|\`integer:space\`  All four statements are distinct from one another in terms of the number of parameterized fields and their names. Given the above assignments, the table below shows examples of  GET request messages, which are represented by the trailing RDB path with query parameters (if any),  and their matching SQL statement.


URL	| Matching SQL Statement
:----------------|:------------------------:
.../parking?id=24	|1
.../parking?id=24&first=john&last=smith	|3
.../parking?id=24&first=john	|2
.../parking/space/23	|4
.../parking/spaces/23	|4Note that the fourth entry in the table above has no query parameters. When this occurs, the RDB uses the last two segments of the URL as a key-value pair in an attempt to find a match. The last two segments of the URL, when used in this context, are referred to as “extra path” information. In this case, the extra path information results in a key-value pair of space:23, whose key matches SQL statement #4. Also note that the fifth entry in the table is the same as the fourth, except that it has “spaces” instead of “space”. Metis will ignore the plural form since spaces represents a collection and the URL is being used to identify one instance in the collection. In the table above, the API request messages’ parameters are being passed in as part of the URL itself or in the form of  URL encoded query parameters. For the GET method, this is the only way to pass in parameters; the GET method does not allow parameters to be passed in via the HTTP request message’s entity body.  If a request message has no query parameters and the RDB has been assigned a SQL statement that has no parameterized field, then that statement will be matched to the request message with no query parameters.  So in the above example, if you were to have defined a fifth SQL statement assigned to “sqls4Get” and that statement had no parameterized fields, then the URL with the “.../space/23” extra path information would have been matched to that fifth statement, and not the fourth. If the RDB does not have any SQL statements assigned to a particular HTTP method and it is asked to service that method, then it returns a 405 (Method Not Allowed) return status to the client. If the RDB has been assigned one or more SQL statements for the method, but it could not find a match, then it returns a 404 (Not Found) status to the client. The only SQL statements that are allowed for the GET method are the SELECT and CALL statements. The CALL statement is used for invoking a stored function or procedure. 
For CALL statements, parameterized fields have one of three possible modes.Mode	|Description
:----------------|:------------------------:IN	|Represents a field that passes in a value OUT	|Represents a field that accepts an output valueINOUT|	Represent a field that is both IN and OUTThe format of the stored function statement is as follows:						`param field` =  call function-name([`param field`, `param field`  ... ])The required parameterized field to the left of the equals sign is assigned the function’s return value; therefore, the only mode that can be assigned to this required field is OUT; therefore, one does not have to specify a mode for that field.  For functions, the optional parameterized fields, found within the parentheses, must have a mode of  IN; therefore, there is no need to specify a mode for these parameters as well. Bottom line, you don’t have to specify a mode for any of the function statement’s parameterized fields.The format of the stored procedure statement is as follows:								call function-name([`param field`, `param field`  ... ])

Unlike the function statement, the stored procedure statement is not in the form of an assignment statement.  By default, the optional parameterized fields, found within the parentheses,  also have a mode of IN. So leaving the mode out simply marks the field as an IN parameter. Unlike the function statement, the parameters within the parentheses can be assigned a mode of OUT or INOUT. The INOUT mode specifies that the field is both an IN and OUT parameter. The snippet below is an example of a RDB, called “hello”, whose sole purpose is to invoke a stored function called, "hello".  Given an input string value, the function returns the string, “Hello \<input string\>”. To invoke this function, the RDB needs to be given a HTTP GET request message with a parameter having a key of “name” and some string value (preferably someone’s name).  So lets suppose the GET request message of  “.../hello?name=Fred” or “.../hello/name/Fred” is given to the RDB (the /hello part is the RDB path). The RDB finds a match and invokes the stored function, which returns “Hello Fred” via the “ostring” OUT parameter.  ```<bean id="hello" class="org.metis.pull.WdsResourceBean">   <property name="sqls4Get">     <list>	<value>`char:ostring` = call hello(`char:name`)</value>    </list> </property> <property name="dataSource" ref="dataSource" /> </bean>```
In the above example RDB, this SQL statement, “\`char:ostring\` = call hello(\`char:name\`)” is mapped to this JDBC prepared statement, “{?  = call hello( ? )} ”.This next example RDB is the same as the one above, except that it has an additional  CALL statement that invokes a stored procedure. The CALL statement for the stored procedure requires two input parameters called, “first” and “last”. When invoked, it returns the string “Hello \<first\> \<last\>” via the OUT parameter called, “ostring”.  Suppose the GET request message of  “.../hello?first=Fred&last=Smith” is given to the RDB (again, the /hello part is the RDB path). The RDB finds a match and invokes the stored procedure, which returns “Hello Fred Smith” via the “ostring” OUT parameter.
```<bean id="hello" class=" org.metis.pull.WdsResourceBean ">   <property name="sqls4Get">     <list>	<value> `char:ostring` = call hello(`char:name`) </value>            <value> call hello(`char:ostring:out`, `char:first`, `char:last`) </value>    </list> </property> <property name="dataSource" ref="dataSource" /> </bean>
```In the above example RDB, this SQL statement, “call hello(\`char:ostring:out\`, \`char:first\`, \`char:last\`)” is mapped to this JDBC prepared statement, “{call hello( ?, ?, ?)}”.OUT parameters and result sets are returned to the HTTP client in the form of JSON objects. An OUT parameter is represented by a single JSON object, where the parameter’s name is the key. Each row of a result set is also represented as a single JSON object, where the column names are the objects’ keys. Please note that a stored procedure may return more than one result set.  The content in the box below represents three JSON objects that are returned to a client. The objects are the output of a stored procedure, where the output comprises one OUT param and one result set.  The key for the OUT param is “count” and the keys (columns) for the result set are “STNO”, “SNAME”, “MAJOR”, “MATH”, “CLASS”, and BDATE. ```[{"count":2},{"STNO":7,"SNAME":"Mario","MAJOR":"MATH","CLASS":null,"BDATE":"1980-08-12"}, {"STNO":62,"SNAME":"Monica","MAJOR":"MATH","CLASS":3,"BDATE":"1980-10-14"}]
```####	sqls4PutThe “sqls4Put” RDB property is used for assigning the RDB a set of SQL statements that are bound to the HTTP PUT method.  The only SQL statements that are allowed for the PUT method are the INSERT, UPDATE  and CALL statements.  Section 9.6 of the HTTP specification (i.e., rfc2616) states the following about the PUT method:  *The PUT method requests that the enclosed entity be stored under the supplied Request-URI. If the Request-URI refers to an already existing resource, the enclosed entity SHOULD be considered as a modified version of the one residing on the origin server. If the Request-URI does not point to an existing resource, and that URI is capable of being defined as a new resource by the requesting user agent, the origin server can create the resource with that URI. If a new resource is created, the origin server MUST inform the user agent via the 201 (Created) response. If an existing resource is modified, either the 200 (OK) or 204 (No Content) response codes SHOULD be sent to indicate successful completion of the request. If the resource could not be created or modified with the Request-URI, an appropriate error response SHOULD be given that reflects the nature of the problem.*Some may ask, “what is the difference between a URI and URL?”. Simply put, URIs identify and URLs locate; however, locations are also used to identify, but there are identifiers that are not locators.  The  “Request-URI” implies the entity’s unique identifier, which for DBMSs equates to a “primary key”.  Section 9.6, then goes on to say this about the PUT and POST methods. *The fundamental difference between the POST and PUT requests is reflected in the different meaning of the Request-URI. The URI in a POST request identifies the resource that will handle the enclosed entity. That resource might be a data-accepting process, a gateway to some other protocol, or a separate entity that accepts annotations. In contrast, the URI in a PUT request identifies the entity enclosed with the request -- the user agent knows what URI is intended and the server MUST NOT attempt to apply the request to some other resource. If the server desires that the request be applied to a different URI.*Applying the above statements to “data stores”, and DBMSs in particular, implies that the PUT must specify the entity’s unique identifier or primary key (PK); therefore, the client issuing the PUT request must have knowledge of the PK.  If a client invokes an API request message that is mapped to an INSERT or UPDATE, that message must carry the primary key of the entity being inserted or updated; however, Metis does not enforce this. If it is an INSERT and that entity already exists, the DBMS will disallow the INSERT and returns a “duplicate key” error.  So the disadvantage of using PUT to INSERT an entity is that the client has to provide the PK that identifies the entity.  While it is usually possible for the client to generate the PK, most application designers prefer that their servers or DBMSs create the PK.  For example, in a hypothetical order entry system, you want the DBMS to control the generation of these identifiers. So what does the client do? Well, it can switch to using POST!Strictly speaking, if the client wishes to use PUT to either INSERT or UPDATE an entity, the client must supply the “full representation” of that entity. In other words, the client must supply all of the entity’s attributes.  As a tool for implementing APIs, Metis allows you to follow this strict interpretation; however, it does not preclude you from implementing an API that follows a more relaxed approach. For example, if you wish, you can implement a partial insert or update of the entity using a PUT.    Okay, now that we’ve gotten all that out of the way, lets get back to describing the “sqls4Put” property.  Here’s an example of a RDB that is used for inserting rows into a database table called, “car” and also used for returning a list of JSON objects that represent all the cars in the car table. ```<bean id= “carrdb” class=“org.metis.pull.WdsResourceBean”> <property name= “sqls4Put”>  <list>	<value>insert into car values (`integer:id`,`varchar:make`,`varchar:model`,`integer:mpg`)</value>  </list> </property> <property name="sqls4Get">  <list>	<value>select * from car</value>  </list> </property> <property name="dataSource" ref="dataSource" /> </bean>```
Note how the “sqls4Put” property has been assigned one INSERT statement for inserting cars into the ‘car’ table. Also, note how the INSERT statement expects to receive the unique  “id” of  the car being inserted, as well as all of the rest of the entity’s attributes.  To have a HTTP client application invoke this particular INSERT statement, you would need to define an API request message with a URL that has the following trailing RDB path and query parameters:	.../car?id=240&make=Ford&model=Fusion&mpg=28However, for the PUT and POST methods, parameters can also be passed in via the request message’s entity body (i.e., HTTP entity body) as either of these two media types:  “application/x-www-form-urlencoded” and  “application/json”. The former type is the same format used for the URL query parameters, while the latter one is used for JSON objects. The following box depicts the contents of an entity body, in the form of  a JSON object, that includes the four input parameters “id”, “make”, “model”, and “mpg”, along with their values.	{“id”:240, “make”:“Ford”, “model”:“Fusion”, “mpg”:28}When passing in JSON objects, Metis allows for “batch” inserts and updates. For example, suppose your client application wants to insert three cars into the car table.  To accomplish that, it can pass in a list or array of JSON objects, one for each INSERT operation, as follows:
```[{“id”:240,“make”:“Ford”,“model”:“Fusion”,“mpg”:28},{“id”:241,“make”:“Ford”,“model”:“F-150”,“mpg”:17},{“id”:242,“make”:“Volkswagon”,“model”:“CC”, “mpg”:25}]```
For more information on JSON and its syntax, please visit the following web site: www.json.org. The following Wikipedia page gives a thorough description of the URL encoded format, which is also referred to as “percent encoding”: en.wikipedia.org/wiki/Percent-encoding.  Now, lets say that you wanted to also be able to do a partial update on one or more existing car entities. To accomplish that you add an UPDATE statement to the RDB, as follows:
``` <bean id="carrdb" class="org.metis.pull.WdsResourceBean "><property name="sqls4Put">  <list>	<value>insert into car values (`integer:id`,`varchar:make`,`varchar:model`,`integer:mpg`)</value>    <value>update car set mpg = `integer:mpg` where id = `integer:id`</value>  </list> </property> <property name="sqls4Get">   <list>	<value>select * from car</value>   </list>  </property> <property name="dataSource" ref="dataSource" /> </bean>```
If you wanted to do a full update, you’d find yourself with a conflict between the full UPDATE and existing INSERT statements. The conflict would arise because both statements would have the same identical sets of parameterized fields. However, you can get around this by assigning the full UPDATE to the “sqls4Post” RDB property. 
If an INSERT is successful, the HTTP client is returned a 201 (Created) response. If an UPDATE is successful, the client is returned a 200 (OK).####	sqls4PostThe “sqls4Post” RDB property is used for assigning the RDB a set of SQL statements that are bound to the HTTP POST method.  The only SQL statements that are allowed for the POST method are the INSERT, UPDATE  and CALL statements.  Except for some minor differences, which are covered in this subsection, Metis services both a POST and PUT in the same manner.  When servicing an INSERT statement that is bound to the POST method, it is assumed that the HTTP client application does not know the unique identifier or primary key (PK) of the entity being inserted. In this case, and as previously mentioned, the client application is allowing the data store (e.g., DBMS) to auto-generate the PK.  Section 9.5 of the HTTP specification (i.e., rfc2616) states the following about the POST method:*If a resource has been created on the origin server, the response SHOULD be 201 (Created) and contain an entity which describes the status of the request and refers to the new resource, and a Location header.*In response to a successful POST-INSERT, Metis returns a 201 (Created) status back to the HTTP client. Since this is a POST-INSERT, Metis assumes the client application has no prior knowledge of the PK; therefore, Metis also returns a HTTP Location response header whose value includes the URL of the request message, minus any query parameters, plus the PK of the just-inserted entity.  For example, suppose the following HTTP POST request message is used to insert a row into the car table:		www.carsrus.com/admin/cars/inventory?make=Ford&model=Fusion&mpg=28Upon successful completion, Metis returns this string value for the Location response header:		www.carsrus.com/admin/cars/inventory/2309The “2309” represents the auto-generated PK of the just-inserted car. This is unlike a successful PUT-INSERT, which assumes the client application has knowledge of the PK and thus does not return a Location header. What Metis does not do is return the full representation of the just-inserted car.  This is true for both PUT and POST. As with a PUT, Metis allows you to use a POST method to perform a batch INSERT or UPDATE.  However, for successful batch INSERTS, Metis does not return the resulting PKs for all the inserted entities.Some DBMSs do not support auto-generated or auto-incrementing primary keys. Oracle for example, requires the use of a sequence. For example, assuming you are using Oracle and have defined a sequence called, “s_car”, the INSERT statement for Oracle would be as follows:		INSERT INTO CAR (id, make, model, mpg) VALUES (s_car.nextval, ‘Ford’, ‘Fusion’, 28);  In this case, the ‘id’ field is the primary key and its value is acquired by incrementing the sequence. Some DBMSs, like MySQL and SQL Server, return the INSERT’s resulting auto-generated key without having to be told the name of they key; while others, like Oracle and PostgreSQL, must be told the name of the key. Therefore, if you are using a DBMS that must be told the name of the key,  you must inform Metis of the primary key’s name. This is done through a reserved  parameterized field whose type is “pkey”. This field can only be used for INSERT statements, is only used to inform Metis of the primary key name, and is not bound to the statement. Here’s an example of how it is used within a WAC file:	INSERT INTO CAR (id, make, model, mpg) VALUES (`pkey:id`,s_car.nextval,`char:make`,`char:model`,`integer:mpg`);The \`pkey:id\` field informs Metis that the primary key name for the target table is “id”.  With this information, Metis will request, from the DBMS, that it return the value of the primary key for the just-inserted row . The resulting prepared statement, for Oracle, will be as follows:  INSERT INTO CAR (id, make, model, mpg) VALUES (s_car.nextval,  ?, ?, ?);Note how the `pkey:id` parameterized field is not bound to the prepared statement. If you are using a DBMS (e.g., MySQL, SQL Server) that does not need to be told the name of the key, you do not have to use the “pkey” type parameterized field; therefore, the corresponding statement in the WAC file is simplified as follows: 	INSERT INTO CAR (make, model, mpg) VALUES (`char:make`, `char:model`, `integer:mpg`);The pkey field can be used for any DBMS; therefore, use the pkey field if you’re not certain that your particular DBMS needs this information. Also, the pkey field can be positioned anywhere in-between the open and close parenthesis following the VALUES keyword.  So if you wish, you can place it at the end as this example illustrates:	INSERT INTO CAR (make, model, mpg) VALUES (`char:make`, `char:model`, `integer:mpg`, `pkey:id`);The above example is for a DBMS other than Oracle, so there is no need to use a sequence. 
####	sqls4DeleteThe “sqls4Delete” RDB property is used for assigning the RDB a set of SQL statements that are bound to the HTTP DELETE method.  The only SQL statements that are allowed for the DELETE method are the DELETE and CALL statements.  Continuing with the car theme, the example RDB below is used to delete an instance of a car from the car table. The DELETE statement deletes the car based on the given car’s PK, which is represented by the “id” parameter. ```<bean id=”carrdb" class="org.metis.pull.WdsResourceBean">   <property name="sqls4Delete">	<list>       <value>delete from car where id =`integer:id`</value>	</list>   </property>   <property name="dataSource" ref="dataSource" /> </bean>```
To have a HTTP client application invoke this particular RDB’s DELETE statement, you would need to define an API request message that is sent via the HTTP DELETE method and has a URL similar to one with the following trailing RDB path and query parameters (if any):.../car?id=240
.../car/240.../cars/240In response to a successful delete, Metis returns to the client application a status of 204 (No content). Unlike the PUT and POST methods, a DELETE method does not support conveying input parameters via the HTTP request message’s entity body. Therefore, the parameters must be passed in by the client application as URL query parameters. This also means that one cannot perform batch deletes. 
####	secureThe “secure” boolean property, whose default setting is false, is used to specify whether the RDB should only accept request messages that are made within the context of a secure HTTP channel (i.e., https channel).  If the RDB’s secure property is set to true and the request message is not delivered within a secure channel, a 401 (Unauthorized) return status code is sent back to the client. The following example illustrates a RDB whose “secure” property has been set to “true”. To set it to false, simply remove the property statement or change “true” to “false”.```<bean id="carrdb" class="org.metis.pull.WdsResourceBean">   <property name="sqls4Delete">	<list>                 <value>delete from car where id =`integer:id`</value>	</list>   </property>   <property name="secure" value="#{true}" />    <property name="dataSource" ref="dataSource" /> </bean>```
The previous  Deployment Descriptor section,  described a Metis servlet init-parameter whose name is also “secure”. That servlet init-parameter is used as a global version of the RDB’s “secure” property. In other words, the value assigned to the servlet’s “secure” init-parameter is assigned to all RDBs whose “secure” property has not been specified.  3.2.3.6	authenticatedThe “authenticated” boolean property, whose default setting is false, is used to specify whether the RDB should only accept request messages that are made by a client application that has been authenticated.  If the RDB’s “authenticated” property is set to true and the request message is not delivered by an authenticated client, a 401 (Unauthorized) return status code is sent back to the client. The following example illustrates a RDB whose “authenticated” property has been set to “true”. To set it to false, simply remove the property statement or change “true” to “false”.```<bean id="carrdb" class="org.metis.pull.WdsResourceBean">   <property name="sqls4Delete">	<list>                 <value>delete from car where id =`integer:id`</value>	</list>   </property>   <property name="secure" value="#{true}" />    <property name="dataSource" ref="dataSource" /> </bean>```
Similar to the previous “secure” property, this “authenticated” property also has a global servlet init-parameter version.    
 

   
